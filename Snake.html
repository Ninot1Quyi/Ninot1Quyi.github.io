<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>è‡ªåŠ¨å¯»è·¯è´ªåƒè›‡æ¸¸æˆ</title>
    <style>
        /* å¼•å…¥Robotoå­—ä½“ */
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

        body {
            background-color: #2c3e50;
            font-family: 'Roboto', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            color: #ecf0f1;
        }

        /* é¡¶éƒ¨ä¿¡æ¯æ  */
        #top-bar {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .info-card {
            display: flex;
            align-items: center;
            background-color: #ecf0f1;
            color: #2c3e50;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-weight: bold;
            flex: 1;
            margin-right: 10px;
            transition: transform 0.3s;
        }

        .info-card:last-child {
            margin-right: 0;
        }

        .info-card:hover {
            transform: translateY(-2px);
        }

        .info-icon {
            margin-right: 8px;
            font-size: 20px;
        }

        /* å›¾æ ‡ä½¿ç”¨Unicodeå­—ç¬¦æˆ–Emoji */
        .algorithm-icon::before {
            content: "ğŸ”";
        }

        .score-icon::before {
            content: "ğŸ†";
        }

        /* æ¸¸æˆå®¹å™¨ */
        #game-container {
            position: relative;
            width: 400px;
            height: 400px;
            background-color: #34495e; /* åœ°å›¾èƒŒæ™¯è‰² */
            border-radius: 20px;
            box-shadow:
                     0 16px 32px rgba(0, 0, 0, 0.4),
                    0 0 30px 15px rgb(56, 58, 60);
            margin-bottom: 20px;
            transition: box-shadow 0.3s, transform 0.3s;
            transform: translateZ(0); /* è§¦å‘GPUåŠ é€Ÿ */
        }

        /* æ¸¸æˆåŒºåŸŸçš„çªå‡ºæ˜¾ç¤ºæ•ˆæœ */
        #game-container:hover {
            box-shadow:
                    0 16px 32px rgba(0, 0, 0, 0.1),
                    0 0 30px 15px rgb(62, 68, 71);
            transform: scale(1.02);
        }

        #gameCanvas {
            background-color: #2c3e50; /* ä¸å®¹å™¨ä¸åŒçš„é¢œè‰² */
            border-radius: 20px;
            width: 100%;
            height: 100%;
            display: block;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: bold;
            color: #e74c3c;
            display: none;
            pointer-events: none;
            z-index: 2;
            background-color: rgba(236, 240, 241, 0.9);
            padding: 20px 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        #controls {
            width: 100%;
            max-width: 500px;
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .control-group {
            margin-bottom: 20px;
            width: 100%;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 700;
            color: #2c3e50;
        }

        /* æ»‘åŠ¨æ¡æ ·å¼ */
        .control-group input[type="range"] {
            width: 100%;
            padding: 5px;
            box-sizing: border-box;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #3498db 0%, #3498db var(--range-value), #bdc3c7 var(--range-value), #bdc3c7 100%);
            outline: none;
            transition: background 0.3s;
        }

        /* æ»‘åŠ¨æ¡æ»‘å—æ ·å¼ */
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            transition: background 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            background: #2980b9;
        }

        /* å¯¹äºéWebkitæµè§ˆå™¨ */
        .control-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            transition: background 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .control-group input[type="range"]::-moz-range-thumb:hover {
            background: #2980b9;
        }

        .algorithm-buttons, #action-buttons {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .algorithm-buttons button, #action-buttons button {
            flex: 1;
            margin-right: 10px;
            padding: 10px;
            cursor: pointer;
            border: none;
            background-color: #3498db;
            color: #ecf0f1;
            border-radius: 5px;
            font-weight: 700;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .algorithm-buttons button:last-child, #action-buttons button:last-child {
            margin-right: 0;
        }

        .algorithm-buttons button:hover, #action-buttons button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        .algorithm-buttons button.selected {
            background-color: #2ecc71;
        }

        #action-buttons button {
            background-color: #e67e22;
        }

        #action-buttons button:hover {
            background-color: #d35400;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 600px) {
            #game-container {
                width: 90vw;
                height: 90vw;
            }

            #top-bar, #controls {
                max-width: 100vw;
            }

            #score {
                width: 100px;
            }
        }
    </style>
</head>
<body>
<div id="top-bar">
    <div class="info-card">
        <span class="info-icon algorithm-icon"></span>
        <span id="status">å½“å‰ç®—æ³•: æ·±åº¦ä¼˜å…ˆæœç´¢</span>

    </div>
    <div class="info-card">
        <span class="info-icon score-icon"></span>
        <span id="score">å¾—åˆ†: 0</span>
    </div>
</div>
<div id="game-container" tabindex="0">
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <div id="game-over">æ¸¸æˆç»“æŸ</div>
</div>
<div id="controls">
    <div class="control-group">
        <label for="obstacleCount">éšœç¢ç‰©æ•°é‡: <span id="obstacleCountValue">10</span></label>
        <input id="obstacleCount" type="range" min="0" max="50" value="10" oninput="updateObstacleCount()">
    </div>
    <div class="control-group">
        <label for="speedControl">è›‡è¿è¡Œé€Ÿåº¦ (æ¯«ç§’): <span id="speedControlValue">100</span></label>
        <input id="speedControl" type="range" min="5" max="150" value="100" oninput="updateSpeed()">
    </div>
    <div class="control-group">
        <label>é€‰æ‹©å¯»è·¯ç®—æ³•:</label>
        <div class="algorithm-buttons">
            <button id="dfsButton" onclick="setAlgorithm('dfs')">æ·±åº¦ä¼˜å…ˆæœç´¢</button>
            <button id="astarButton" onclick="setAlgorithm('astar')">A*ç®—æ³•</button>
            <button id="greedyButton" onclick="setAlgorithm('greedy')">è´ªå¿ƒæœ€ä½³ä¼˜å…ˆæœç´¢</button>
        </div>
    </div>
    <div class="control-group">
        <div id="action-buttons">
            <button onclick="restartGame()">é‡æ–°å¼€å§‹æ¸¸æˆ</button>
            <button onclick="pauseGame()">æš‚åœ/ç»§ç»­æ¸¸æˆ</button>
        </div>
    </div>
</div>
<script>
    'use strict';

    // è·å–ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ç½‘æ ¼å¤§å°å’Œç½‘æ ¼æ•°é‡
    const gridSize = 20;
    const tileCount = canvas.width / gridSize;

    // è›‡ã€é£Ÿç‰©å’Œéšœç¢ç‰©çš„æ•°æ®ç»“æ„
    let snake = [];
    let food = {};
    let obstacles = [];
    let currentAlgorithm = 'dfs';

    // æ¸¸æˆæ§åˆ¶å˜é‡
    let gameInterval;
    let currentPath = null;
    let isPaused = false;
    let score = 0;

    // æ–¹å‘å‘é‡
    const directions = [
        {x:0, y:-1}, // ä¸Š
        {x:1, y:0},  // å³
        {x:0, y:1},  // ä¸‹
        {x:-1, y:0}  // å·¦
    ];

    /**
     * éšæœºæ‰“ä¹±æ•°ç»„é¡ºåºï¼ˆFisher-Yates Shuffleï¼‰
     * @param {Array} array - è¦æ‰“ä¹±çš„æ•°ç»„
     */
    function shuffleArray(array) {
        for (let i = array.length -1; i >0; i--) {
            const j = Math.floor(Math.random() * (i+1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    // åˆå§‹åŒ–æ¸¸æˆ
    function startGame() {
        snake = [{x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2)}];
        score = 0;
        updateScore();
        generateObstacles(); // å…ˆç”Ÿæˆéšœç¢ç‰©
        generateFood(); // å†ç”Ÿæˆé£Ÿç‰©ï¼Œç¡®ä¿å¯è¾¾
        currentPath = null; // é‡ç½®è·¯å¾„
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, parseInt(document.getElementById('speedControl').value));
        updateStatus();
        hideGameOver();
    }

    // é‡æ–°å¼€å§‹æ¸¸æˆ
    function restartGame() {
        clearInterval(gameInterval);
        startGame();
    }

    // æš‚åœ/ç»§ç»­æ¸¸æˆ
    function pauseGame() {
        if (isPaused) {
            gameInterval = setInterval(gameLoop, parseInt(document.getElementById('speedControl').value));
            updateStatus();
        } else {
            clearInterval(gameInterval);
            updateStatus("å·²æš‚åœ");
        }
        isPaused = !isPaused;
    }

    // æ›´æ–°è›‡è¿è¡Œé€Ÿåº¦
    function updateSpeed() {
        const speed = parseInt(document.getElementById('speedControl').value);
        document.getElementById('speedControlValue').innerText = speed;
        document.getElementById('speedControl').style.setProperty('--range-value', `${(speed - 5) / (150 - 5) * 100}%`);
        clearInterval(gameInterval);
        if (!isPaused) {
            gameInterval = setInterval(gameLoop, speed);
        }
    }

    // æ›´æ–°éšœç¢ç‰©æ•°é‡
    function updateObstacleCount() {
        const count = parseInt(document.getElementById('obstacleCount').value);
        document.getElementById('obstacleCountValue').innerText = count;
        document.getElementById('obstacleCount').style.setProperty('--range-value', `${count / 50 * 100}%`);
        generateObstacles();
        generateFood(); // é‡æ–°ç”Ÿæˆé£Ÿç‰©ï¼Œç¡®ä¿å¯è¾¾
        currentPath = null; // é‡ç½®è·¯å¾„ä»¥é‡æ–°å¯»è·¯
    }

    /**
     * ç”Ÿæˆé£Ÿç‰©ï¼Œç¡®ä¿é£Ÿç‰©ä¸ä¸è›‡å’Œéšœç¢ç‰©é‡å ï¼Œå¹¶ä¸”å¯è¾¾
     */
    function generateFood() {
        const availableCells = [];

        for (let x = 0; x < tileCount; x++) {
            for (let y = 0; y < tileCount; y++) {
                if (!isOccupied(x, y)) {
                    availableCells.push({x, y});
                }
            }
        }

        if (availableCells.length === 0) {
            // æ— å¯ç”¨ä½ç½®ï¼Œæ¸¸æˆèƒœåˆ©
            endGame(true);
            return;
        }

        shuffleArray(availableCells);

        for (const cell of availableCells) {
            const path = findPath(snake[0], cell);
            if (path) {
                food = cell;
                return;
            }
        }

        // å¦‚æœæ²¡æœ‰å¯è¾¾çš„é£Ÿç‰©ä½ç½®ï¼Œæ¸¸æˆèƒœåˆ©
        endGame(true);
    }

    // æ£€æŸ¥ä½ç½®æ˜¯å¦è¢«å ç”¨
    function isOccupied(x, y) {
        for (const segment of snake) {
            if (segment.x === x && segment.y === y) return true;
        }
        for (const obstacle of obstacles) {
            if (obstacle.x === x && obstacle.y === y) return true;
        }
        return false;
    }

    /**
     * ç”Ÿæˆéšœç¢ç‰©ï¼Œç¡®ä¿éšœç¢ç‰©ä¸ç”Ÿæˆåœ¨è›‡çš„èº«ä½“ä¸Š
     * ä»¥åŠä¸ç”Ÿæˆåœ¨è›‡å¤´å‘¨å›´çš„8ä¸ªæ ¼å­å†…
     */
    function generateObstacles() {
        obstacles = [];
        const desiredObstacleCount = parseInt(document.getElementById('obstacleCount').value) || 10;
        const forbiddenCells = getForbiddenCells();

        while (obstacles.length < desiredObstacleCount) {
            let obstacle;
            let valid = false;
            let attempts = 0;
            const maxAttempts = 1000; // é˜²æ­¢æ— é™å¾ªç¯

            while (!valid && attempts < maxAttempts) {
                obstacle = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                const key = `${obstacle.x},${obstacle.y}`;
                // ç¡®ä¿éšœç¢ç‰©ä¸åœ¨è›‡çš„èº«ä½“ä¸Šï¼Œä¹Ÿä¸åœ¨ç¦æ­¢ç”Ÿæˆçš„æ ¼å­å†…
                if (!isOccupied(obstacle.x, obstacle.y) && !forbiddenCells.has(key)) {
                    valid = true;
                }
                attempts++;
            }

            if (valid) {
                obstacles.push(obstacle);
            } else {
                console.warn('æ— æ³•ç”Ÿæˆè¶³å¤Ÿçš„éšœç¢ç‰©ï¼Œå°è¯•å‡å°‘éšœç¢ç‰©æ•°é‡ã€‚');
                break;
            }
        }
    }

    /**
     * è·å–è›‡å¤´å‘¨å›´çš„8ä¸ªæ ¼å­
     * @returns {Set} ç¦æ­¢ç”Ÿæˆéšœç¢ç‰©çš„æ ¼å­åæ ‡é›†åˆ
     */
    function getForbiddenCells() {
        const forbidden = new Set();
        if (snake.length === 0) return forbidden;
        const head = snake[0];
        const headX = head.x;
        const headY = head.y;

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                if (dx === 0 && dy === 0) continue; // æ’é™¤è›‡å¤´è‡ªèº«
                const nx = headX + dx;
                const ny = headY + dy;
                if (nx >= 0 && nx < tileCount && ny >= 0 && ny < tileCount) {
                    forbidden.add(`${nx},${ny}`);
                }
            }
        }
        return forbidden;
    }

    // æ¸¸æˆä¸»å¾ªç¯
    function gameLoop() {
        try {
            const path = findPath(snake[0], food);
            if (path) {
                // ä»…åœ¨æ–°è·¯å¾„æ¯”å½“å‰è·¯å¾„æ›´çŸ­æ—¶æ‰æ›´æ–°
                if (!currentPath || path.length < currentPath.length) {
                    currentPath = path;
                }

                if (currentPath && currentPath.length > 1) {
                    const nextMove = currentPath[1];
                    snake.unshift({x: nextMove.x, y: nextMove.y});
                    if (nextMove.x === food.x && nextMove.y === food.y) {
                        score += 1;
                        updateScore();
                        generateObstacles(); // å…ˆç”Ÿæˆéšœç¢ç‰©
                        generateFood(); // å†ç”Ÿæˆé£Ÿç‰©ï¼Œç¡®ä¿å¯è¾¾
                        currentPath = null;
                    } else {
                        snake.pop();
                        currentPath.shift();
                    }
                } else {
                    endGame();
                    return;
                }
            } else {
                endGame();
                return;
            }

            if (isGameOver()) {
                endGame();
                return;
            }

            drawGame(currentPath);
        } catch (error) {
            console.error('æ¸¸æˆå¾ªç¯å‡ºé”™:', error);
            clearInterval(gameInterval);
            alert('æ¸¸æˆå‡ºç°é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ä»¥è·å–è¯¦ç»†ä¿¡æ¯ã€‚');
        }
    }

    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
    function isGameOver() {
        const head = snake[0];
        // æ£€æŸ¥æ˜¯å¦æ’åˆ°è‡ªèº«
        for (let i = 1; i < snake.length; i++) {
            if (snake[i].x === head.x && snake[i].y === head.y) {
                return true;
            }
        }
        // æ£€æŸ¥æ˜¯å¦æ’åˆ°éšœç¢ç‰©
        for (const obstacle of obstacles) {
            if (obstacle.x === head.x && obstacle.y === head.y) {
                return true;
            }
        }
        return false;
    }

    // ç»“æŸæ¸¸æˆ
    function endGame(victory = false) {
        clearInterval(gameInterval);
        showGameOver(victory);
    }

    // æ˜¾ç¤ºæ¸¸æˆç»“æŸ
    function showGameOver(victory) {
        const gameOverDiv = document.getElementById('game-over');
        gameOverDiv.innerText = 'æ¸¸æˆç»“æŸ';
        gameOverDiv.style.display = 'block';
    }

    // éšè—æ¸¸æˆç»“æŸ
    function hideGameOver() {
        const gameOverDiv = document.getElementById('game-over');
        gameOverDiv.style.display = 'none';
    }

    // æ›´æ–°å¾—åˆ†æ˜¾ç¤º
    function updateScore() {
        document.getElementById('score').innerText = `å¾—åˆ†: ${score}`;
    }

    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
    function updateStatus(additionalInfo = "") {
        let statusText = `å½“å‰ç®—æ³•: ${getAlgorithmName(currentAlgorithm)}`;
        if (additionalInfo) {
            statusText += ` (${additionalInfo})`;
        }
        document.getElementById('status').innerText = statusText;
    }

    // æŸ¥æ‰¾è·¯å¾„
    function findPath(start, goal) {
        if (currentAlgorithm === 'dfs') {
            return dfs(start, goal);
        } else if (currentAlgorithm === 'astar') {
            return astar(start, goal);
        } else if (currentAlgorithm === 'greedy') {
            return greedyBestFirstSearch(start, goal);
        }
        return null;
    }

    // æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)
    function dfs(start, goal) {
        const stack = [];
        const visited = {};
        const cameFrom = {};
        stack.push(start);
        visited[`${start.x},${start.y}`] = true;

        const directionOrder = getDirectionOrder(start, goal);

        while (stack.length > 0) {
            const current = stack.pop();
            if (current.x === goal.x && current.y === goal.y) {
                return reconstructPath(cameFrom, current);
            }

            const neighbors = getNeighbors(current, directionOrder);
            for (const neighbor of neighbors) {
                const key = `${neighbor.x},${neighbor.y}`;
                if (!visited[key]) {
                    visited[key] = true;
                    cameFrom[key] = current;
                    stack.push(neighbor);
                }
            }
        }
        return null;
    }

    // è·å–æ–¹å‘é¡ºåºï¼Œä¼˜å…ˆæœå‘ç›®æ ‡æ–¹å‘
    function getDirectionOrder(start, goal) {
        const dx = goal.x - start.x;
        const dy = goal.y - start.y;
        const order = directions.slice();

        order.sort((a, b) => {
            const aDist = Math.abs(a.x * dx) + Math.abs(a.y * dy);
            const bDist = Math.abs(b.x * dx) + Math.abs(b.y * dy);
            return bDist - aDist;
        });

        return order;
    }

    // A* ç®—æ³•
    function astar(start, goal) {
        const openSet = [];
        const cameFrom = {};
        const gScore = {};
        const fScore = {};
        const visited = {};

        const startKey = `${start.x},${start.y}`;
        gScore[startKey] = 0;
        fScore[startKey] = heuristic(start, goal);

        openSet.push({node: start, fScore: fScore[startKey]});

        while (openSet.length > 0) {
            openSet.sort((a, b) => a.fScore - b.fScore);
            const current = openSet.shift().node;
            const currentKey = `${current.x},${current.y}`;

            if (current.x === goal.x && current.y === goal.y) {
                return reconstructPath(cameFrom, current);
            }

            visited[currentKey] = true;

            const neighbors = getNeighbors(current);
            for (const neighbor of neighbors) {
                const neighborKey = `${neighbor.x},${neighbor.y}`;

                if (visited[neighborKey]) continue;

                const tentative_gScore = gScore[currentKey] + 1;

                if (gScore[neighborKey] === undefined || tentative_gScore < gScore[neighborKey]) {
                    cameFrom[neighborKey] = current;
                    gScore[neighborKey] = tentative_gScore;
                    fScore[neighborKey] = gScore[neighborKey] + heuristic(neighbor, goal);

                    if (!openSet.some(n => n.node.x === neighbor.x && n.node.y === neighbor.y)) {
                        openSet.push({node: neighbor, fScore: fScore[neighborKey]});
                    }
                }
            }
        }
        return null;
    }

    // è´ªå¿ƒæœ€ä½³ä¼˜å…ˆæœç´¢ (Greedy Best-First Search)
    function greedyBestFirstSearch(start, goal) {
        const openSet = [];
        const cameFrom = {};
        const visited = {};

        openSet.push(start);
        visited[`${start.x},${start.y}`] = true;

        while (openSet.length > 0) {
            // æŒ‰ç…§å¯å‘å¼å‡½æ•°æ’åºï¼Œè´ªå¿ƒé€‰æ‹©æœ€æ¥è¿‘ç›®æ ‡çš„èŠ‚ç‚¹
            openSet.sort((a, b) => heuristic(a, goal) - heuristic(b, goal));
            const current = openSet.shift();

            if (current.x === goal.x && current.y === goal.y) {
                return reconstructPath(cameFrom, current);
            }

            const neighbors = getNeighbors(current);
            for (const neighbor of neighbors) {
                const key = `${neighbor.x},${neighbor.y}`;
                if (!visited[key]) {
                    visited[key] = true;
                    cameFrom[key] = current;
                    openSet.push(neighbor);
                }
            }
        }
        return null;
    }

    // æ›¼å“ˆé¡¿è·ç¦»å¯å‘å¼å‡½æ•°
    function heuristic(a, b) {
        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
    }

    // è·¯å¾„é‡å»ºå‡½æ•°
    function reconstructPath(cameFrom, current) {
        const path = [current];
        let key = `${current.x},${current.y}`;
        while (cameFrom[key]) {
            current = cameFrom[key];
            path.unshift(current);
            key = `${current.x},${current.y}`;
        }
        return path;
    }

    /**
     * è·å–é‚»å±…èŠ‚ç‚¹
     * @param {Object} node - å½“å‰èŠ‚ç‚¹
     * @param {Array} [customDirections] - è‡ªå®šä¹‰æ–¹å‘é¡ºåº
     * @returns {Array} é‚»å±…èŠ‚ç‚¹æ•°ç»„
     */
    function getNeighbors(node, customDirections) {
        const result = [];
        const directionSet = customDirections || directions;
        for (const dir of directionSet) {
            const nx = node.x + dir.x;
            const ny = node.y + dir.y;
            if (nx >= 0 && nx < tileCount && ny >= 0 && ny < tileCount && !isOccupied(nx, ny)) {
                result.push({x: nx, y: ny});
            }
        }
        return result;
    }

    // ç»˜åˆ¶æ¸¸æˆ
    function drawGame(path) {
        // æ¸…ç©ºç”»å¸ƒ
        ctx.fillStyle = '#34495e'; // åœ°å›¾èƒŒæ™¯è‰²
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ç»˜åˆ¶è·¯å¾„
        if (path) {
            drawPath(path);
        }

        // ç»˜åˆ¶éšœç¢ç‰©
        for (const obstacle of obstacles) {
            ctx.save();
            ctx.fillStyle = '#7f8c8d';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize - 2, gridSize - 2);
            ctx.restore();
        }

        // ç»˜åˆ¶é£Ÿç‰©
        ctx.fillStyle = '#e74c3c';
        ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);

        // æ˜¾ç¤ºé£Ÿç‰©ä½ç½®çš„è·¯å¾„é•¿åº¦
        ctx.fillStyle = '#ecf0f1';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(path ? path.length : 0, food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2);

        // ç»˜åˆ¶è›‡
        for (let i = 0; i < snake.length; i++) {
            if (i === 0) {
                ctx.fillStyle = '#27ae60'; // è›‡å¤´é¢œè‰²
            } else {
                const gradientFactor = i / snake.length;
                ctx.fillStyle = `rgba(46, 204, 113, ${1 - gradientFactor * 0.7})`;
            }
            ctx.fillRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize - 2, gridSize - 2);
        }
    }

    // ç»˜åˆ¶æ‰€æœ‰ç®—æ³•çš„è·¯å¾„ä¸ºç»¿è‰²
    function drawPath(path) {
        ctx.strokeStyle = '#2ecc71'; // ç»¿è‰²è·¯å¾„
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        for (let i = 0; i < path.length - 1; i++) {
            const from = path[i];
            const to = path[i + 1];
            ctx.moveTo(from.x * gridSize + gridSize / 2, from.y * gridSize + gridSize / 2);
            ctx.lineTo(to.x * gridSize + gridSize / 2, to.y * gridSize + gridSize / 2);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.lineWidth = 1;
    }

    // è®¾ç½®å¯»è·¯ç®—æ³•
    function setAlgorithm(algorithm) {
        if (currentAlgorithm !== algorithm) {
            currentAlgorithm = algorithm;
            currentPath = null; // é‡ç½®è·¯å¾„ä»¥é€‚åº”æ–°çš„ç®—æ³•
            highlightSelectedButton();
            updateStatus();
        }
    }

    // è·å–ç®—æ³•åç§°
    function getAlgorithmName(algorithm) {
        if (algorithm === 'dfs') return 'æ·±åº¦ä¼˜å…ˆæœç´¢';
        if (algorithm === 'astar') return 'A*ç®—æ³•';
        if (algorithm === 'greedy') return 'è´ªå¿ƒæœ€ä½³ä¼˜å…ˆæœç´¢';
        return 'æœªçŸ¥ç®—æ³•';
    }

    // é«˜äº®æ˜¾ç¤ºå½“å‰é€‰ä¸­çš„ç®—æ³•æŒ‰é’®
    function highlightSelectedButton() {
        document.getElementById('dfsButton').classList.remove('selected');
        document.getElementById('astarButton').classList.remove('selected');
        document.getElementById('greedyButton').classList.remove('selected');

        if (currentAlgorithm === 'dfs') {
            document.getElementById('dfsButton').classList.add('selected');
        } else if (currentAlgorithm === 'astar') {
            document.getElementById('astarButton').classList.add('selected');
        } else if (currentAlgorithm === 'greedy') {
            document.getElementById('greedyButton').classList.add('selected');
        }
    }

    // åˆå§‹åŒ–æ¸¸æˆ
    window.onload = function() {
        startGame();
        highlightSelectedButton();
        // åˆå§‹åŒ–æ»‘åŠ¨æ¡å¡«å……
        document.getElementById('speedControl').style.setProperty('--range-value', `${(parseInt(document.getElementById('speedControl').value) - 5) / (150 - 5) * 100}%`);
        document.getElementById('obstacleCount').style.setProperty('--range-value', `${parseInt(document.getElementById('obstacleCount').value) / 50 * 100}%`);
    };
</script>
</body>
</html>
